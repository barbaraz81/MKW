% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/reg_param_t_test.R
\name{reg.param.t.test}
\alias{reg.param.t.test}
\title{T-test of two regression slopes or intercepts}
\usage{
reg.param.t.test(x, y, factor, x2, y2, object_1, object_2, delta, parameter)
}
\arguments{
\item{x}{the x-values to be used. Can contain the two groups of data if the parameter \code{factor} is provided. Otherwise, contain the x-values for the first group.}

\item{y}{the y-values to be used. As for \code{x}, it can contain the two groups of data if the parameter \code{factor} is provided. Otherwise, contain the y-values for the first group.}

\item{factor}{mandatory if providing \code{x} and \code{y} data to separate two groups.}

\item{x2}{the x-values to be used for the second group.}

\item{y2}{the y-values to be used for the second group.}

\item{object_1}{the output of the linear model for the first group; can be an output of \code{"lm"} or of \code{"summary(lm)"}}

\item{object_2}{the output of the linear model for the second group; can be an output of \code{"lm"} or of \code{"summary(lm)"}}

\item{parameter}{the parameter of the regression line to be tested; by default the \code{"slope"}, otherwise can be the \code{"intercept"}}
}
\value{
Returns an object containing the absolute difference between the two estimated parameters (\code{$Estimate}), the standard error of this difference (\code{$Std. Error}), the t-value of the t-test (\code{$t value}), the degrees of freedom of the test (\code{$df}) and the p-value of the bilateral t-test (\code{$p-value}).
}
\description{
This function performs a t-test to test whether two regression slopes or two regression intercepts are equal or not.
It can also be used to test whether a regression slope or intercept is equal to a given value.
}
\details{
The t-test can be performed on two \code{x} and \code{y} value vectors if also bringing a factor vector separating the x and y data in two subgroups.
It can also be performed on two independant \code{x} and \code{y} value vectors, that are \code{x}, \code{y}, \code{x2} and \code{y2}.
Finally, it can be performed on two lm outputs (no matter if the output comes from \code{lm()} or \code{summary(lm()))}.
}
\examples{

## To test a pre-established vs estimated parameter
x<-c(sort(runif(100,0,100)))
y<-c()
slope<-runif(1,-100,100)
intercept<-runif(1,-100,100)
for (i in 1:length(x)){
  y[i]<-x[i]*slope+intercept+runif(1,-abs(slope)/100,abs(slope)/100)
}
parameter<-"slope"
reg.param.t.test(x,y,slope,parameter)
reg.param.t.test(y~x,slope,"slope")
reg.param.t.test(lm(y~x),slope,parameter) ## This tests if the function retrieves the original defined slope as equal to the slope of
reg.param.t.test(lm(y~x),intercept,"intercept") ## This tests if the function retrieves the original defined intercept as equal to the intercept of lm()
reg.param.t.test(lm(y~x),0,parameter)[c(1,2,3,5)]==summary(lm(y~x))$coefficients[2,]
reg.param.t.test(lm(y~x),0,"intercept")[c(1,2,3,5)]==summary(lm(y~x))$coefficients[1,]

## To compare two pre-established slopes
x1<-sort(runif(50,0,20))
x2<-sort(runif(50,0,20))
slope1<-runif(1,-100,100)
intercept<-runif(1,-100,100)
slope2<-runif(1,-100,100)
for (i in 1:length(x1)){
  y1[i]<-x1[i]*slope1+intercept+runif(1,-abs(slope1)/100,abs(slope1)/100)
  y2[i]<-x2[i]*slope2+intercept+runif(1,-abs(slope2)/100,abs(slope2)/100)
}
x12<-c(x1,x2)
y12<-c(y1,y2)
fac<-c(rep("1",50),rep("2",50))
object_1<-summary(lm(y12[fac==levels(factor(fac))[1]]~x12[fac==levels(factor(fac))[1]]))
object_2<-summary(lm(y12[fac==levels(factor(fac))[2]]~x12[fac==levels(factor(fac))[2]]))
plot(x1,y1,type="l",col="blue",ylim=c(min(min(y1),min(y2)),max(max(y1),max(y2))))
points(x2,y2,type="l",col="red")
reg.param.t.test(x12,y12,fac,parameter)
reg.param.t.test(y12~x12,fac,parameter)
reg.param.t.test(y1~x1,y2~x2,parameter)
reg.param.t.test(x1,y1,x2,y2,parameter)
reg.param.t.test(object_1,object_2,parameter)
summary(lm(y12~x12*fac))$coefficients[4,] ## Results do not perfectly fit but are roughly the same, don't know why now...

}
