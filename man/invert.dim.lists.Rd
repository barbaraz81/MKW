% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/invert_dim_lists.R
\name{invert.dim.lists}
\alias{invert.dim.lists}
\title{Invert dimensions of a list of lists (with 2 or more successive listings)}
\usage{
invert.dim.lists(lists, new.order)
}
\arguments{
\item{lists}{The list of lists (with 2 or more successive listings)}

\item{new.order}{A numeric vector specifying the re-ordering of all sub-lists}
}
\description{
Inverts the successive listings of a list of lists
}
\examples{
# Get a list with various type of elements and three sublevels
set.seed(1)
list<-lapply(c(1:5),function(x){lapply(c(1:4),function(y){lapply(c(1:3),function(z){
  n<-sample(c(1:5),1)
  out<-NULL
  if(n==1){out<-letters[1:sample(c(2:26),1)]}
  else if(n==2){out<-runif(sample(c(10:100),1))}
  else if(n==3){out<-sample(c(TRUE,FALSE),50,replace=TRUE)}
  else if(n==4){out<-matrix("a",ncol=4,nrow=sample(c(6:12),1))}
  else if(n==5){out<-"hey"}
  out
})})})
list
length(list)
length(list[[1]])
length(list[[1]][[1]])
# Without names to the list
invert.dim.lists(list,c(3,2,1))
# Set names for each elements: x for first order elements, y for second order ones, z for third order ones (so that we can check whether the function performs well)
names(list)<-paste("x",1:length(list),sep="")
for(i in 1:length(list)){
  names(list[[i]])<-paste("y",1:length(list[[i]]),sep="")
  for(j in 1:length(list[[i]])){
    names(list[[i]][[j]])<-paste("z",1:length(list[[i]][[j]]),sep="")
  }
}
list
invert.dim.lists(list,c(3,2,1))
}
